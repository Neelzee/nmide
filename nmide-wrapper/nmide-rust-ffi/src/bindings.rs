/* automatically generated by rust-bindgen 0.69.4 */

pub const CAttribute_Style: CAttribute = 0;
pub const CAttribute_Alt: CAttribute = 1;
pub const CAttribute_Src: CAttribute = 2;
pub const CAttribute_Href: CAttribute = 3;
pub const CAttribute_OnClick: CAttribute = 4;
pub const CAttribute_OnHover: CAttribute = 5;
pub const CAttribute_OnLeave: CAttribute = 6;
pub const CAttribute_OnEnter: CAttribute = 7;
#[doc = " Enumeration of different HTML Attributes"]
pub type CAttribute = ::std::os::raw::c_uint;
pub const CStyle_Width: CStyle = 0;
pub const CStyle_Height: CStyle = 1;
pub const CStyle_Padding: CStyle = 2;
pub const CStyle_PaddingTop: CStyle = 3;
pub const CStyle_PaddingBottom: CStyle = 4;
pub const CStyle_PaddingRight: CStyle = 5;
pub const CStyle_PaddingLeft: CStyle = 6;
pub const CStyle_Margin: CStyle = 7;
pub const CStyle_MarginTop: CStyle = 8;
pub const CStyle_MarginBottom: CStyle = 9;
pub const CStyle_MarginRight: CStyle = 10;
pub const CStyle_MarginLeft: CStyle = 11;
pub const CStyle_BackgroundColor: CStyle = 12;
pub type CStyle = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CColor {
    pub R: ::std::os::raw::c_uchar,
    pub G: ::std::os::raw::c_uchar,
    pub B: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_CColor() {
    const UNINIT: ::std::mem::MaybeUninit<CColor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CColor>(),
        3usize,
        concat!("Size of: ", stringify!(CColor))
    );
    assert_eq!(
        ::std::mem::align_of::<CColor>(),
        1usize,
        concat!("Alignment of ", stringify!(CColor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).R) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(CColor), "::", stringify!(R))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).G) as usize - ptr as usize },
        1usize,
        concat!("Offset of field: ", stringify!(CColor), "::", stringify!(G))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).B) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(CColor), "::", stringify!(B))
    );
}
extern "C" {
    #[doc = " Creates a new CColor, with capped RGB values"]
    pub fn CColorNew(
        r: ::std::os::raw::c_int,
        g: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
    ) -> CColor;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CAttr {
    pub key: CAttribute,
    pub value: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_CAttr() {
    const UNINIT: ::std::mem::MaybeUninit<CAttr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CAttr>(),
        16usize,
        concat!("Size of: ", stringify!(CAttr))
    );
    assert_eq!(
        ::std::mem::align_of::<CAttr>(),
        8usize,
        concat!("Alignment of ", stringify!(CAttr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CAttr),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CAttr),
            "::",
            stringify!(value)
        )
    );
}
pub const CStyleUnit_Pixel: CStyleUnit = 0;
pub const CStyleUnit_REM: CStyleUnit = 1;
pub const CStyleUnit_Percent: CStyleUnit = 2;
pub type CStyleUnit = ::std::os::raw::c_uint;
#[doc = " CBoxProperty are all styles pertaining to spacing of CSS elements.\n\n Example: Width, Height, Padding-*, Margin-*"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBoxProperty {
    pub unit: CStyleUnit,
    pub value: f64,
}
#[test]
fn bindgen_test_layout_CBoxProperty() {
    const UNINIT: ::std::mem::MaybeUninit<CBoxProperty> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CBoxProperty>(),
        16usize,
        concat!("Size of: ", stringify!(CBoxProperty))
    );
    assert_eq!(
        ::std::mem::align_of::<CBoxProperty>(),
        8usize,
        concat!("Alignment of ", stringify!(CBoxProperty))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBoxProperty),
            "::",
            stringify!(unit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBoxProperty),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " CBoxProperty are all styles pertaining to spacing of CSS elements.\n\n Example: Width, Height, Padding-*, Margin-*"]
pub type CWidth = CBoxProperty;
pub const CElement_Div: CElement = 0;
pub const CElement_P: CElement = 1;
pub const CElement_Span: CElement = 2;
pub const CElement_Section: CElement = 3;
pub const CElement_Input: CElement = 4;
pub const CElement_Button: CElement = 5;
pub const CElement_Script: CElement = 6;
pub const CElement_Select: CElement = 7;
pub const CElement_Aside: CElement = 8;
pub const CElement_Nav: CElement = 9;
pub const CElement_A: CElement = 10;
pub const CElement_None: CElement = 11;
#[doc = " Enumeration of HTML-Elements"]
pub type CElement = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CHtmlText {
    pub text: *mut ::std::os::raw::c_char,
    pub len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CHtmlText() {
    const UNINIT: ::std::mem::MaybeUninit<CHtmlText> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CHtmlText>(),
        16usize,
        concat!("Size of: ", stringify!(CHtmlText))
    );
    assert_eq!(
        ::std::mem::align_of::<CHtmlText>(),
        8usize,
        concat!("Alignment of ", stringify!(CHtmlText))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CHtmlText),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CHtmlText),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CHtmlUnion {
    pub kind: CElement,
    pub text: CHtmlText,
}
#[test]
fn bindgen_test_layout_CHtmlUnion() {
    const UNINIT: ::std::mem::MaybeUninit<CHtmlUnion> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CHtmlUnion>(),
        16usize,
        concat!("Size of: ", stringify!(CHtmlUnion))
    );
    assert_eq!(
        ::std::mem::align_of::<CHtmlUnion>(),
        8usize,
        concat!("Alignment of ", stringify!(CHtmlUnion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kind) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CHtmlUnion),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CHtmlUnion),
            "::",
            stringify!(text)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CHtml {
    pub node: CHtmlUnion,
    pub isNode: ::std::os::raw::c_int,
    pub kids: *mut CHtml,
    pub kid_count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CHtml() {
    const UNINIT: ::std::mem::MaybeUninit<CHtml> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CHtml>(),
        40usize,
        concat!("Size of: ", stringify!(CHtml))
    );
    assert_eq!(
        ::std::mem::align_of::<CHtml>(),
        8usize,
        concat!("Alignment of ", stringify!(CHtml))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CHtml),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isNode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CHtml),
            "::",
            stringify!(isNode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kids) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CHtml),
            "::",
            stringify!(kids)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kid_count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CHtml),
            "::",
            stringify!(kid_count)
        )
    );
}
extern "C" {
    #[doc = " Empty div"]
    pub fn div() -> CHtml;
}
extern "C" {
    #[doc = " Empty p"]
    pub fn p() -> CHtml;
}
extern "C" {
    #[doc = " Empty span"]
    pub fn span() -> CHtml;
}
extern "C" {
    #[doc = " Empty section"]
    pub fn section() -> CHtml;
}
extern "C" {
    #[doc = " Empty input"]
    pub fn input() -> CHtml;
}
extern "C" {
    #[doc = " Empty button"]
    pub fn button() -> CHtml;
}
extern "C" {
    #[doc = " Empty script"]
    pub fn script() -> CHtml;
}
extern "C" {
    #[doc = " Empty select"]
    pub fn select() -> CHtml;
}
extern "C" {
    #[doc = " Empty aside"]
    pub fn aside() -> CHtml;
}
extern "C" {
    #[doc = " Empty nav"]
    pub fn nav() -> CHtml;
}
extern "C" {
    #[doc = " Empty a"]
    pub fn a() -> CHtml;
}
extern "C" {
    #[doc = " Empty text"]
    pub fn text() -> CHtml;
}
extern "C" {
    #[doc = " <div>\n  <p>Hello, World!</p>\n </div>"]
    pub fn simple_test() -> CHtml;
}
