\chapter{Introduction}

Standard \gls{ide} is an indispensable tool in software development, offering
features like early bug reporting, project outline visualization, code
highlighting, and code completion However, these \gls{ide}s may not adequately
support the unique demands of experimental programming languages. To solve this,
a modular approach is used to designed an \gls{ide}.
\todo{Rewrite this}

\section{Experimental Languages}

Experimental languages introduce new concepts like \gls{asr} Transformation,
Term Algebras, Mathematics of Arrays, and \gls{stf}. These are concepts from the
academic community, and are not common in \textit{mainstream} languages, and
thus, have little to now support in modern \gls{ide}s. For researches developing
these experimental languages, work arounds are needed, mostly in the form of
creating addons to the application, that gives it the capabilities needed to
partially or fully support the concept being introduced. This means that
experimental concepts cannot be easily tested, because time has to be
invested into an \gls{ide} to investigate the changes needed, if that is
even possible, to enable this experimental concept to be used in the \gls{ide}.


\section{Integrated Development Environment}

An \gls{ide}, aids a developer, as all the needed tools for development are
integrated into one application. There are two different kinds of \gls{ide}s,
generic and specialized. \todo{Source}

A specialized \gls{ide} is one targeted towards a specific language, like
Eclipse, (reference?), or IntelliJ (reference?), which target Java/JVM. It
contains specialized features like the following:

\todo{Rewrite the following paragraphs}

\paragraph{Syntax Highlighting} Highlighting important keywords, identifiers
and more, makes the language easier to read for the developer, allowing them to
spot easy to miss errors, like misspelling of keywords.

\paragraph{Code Autocompletion} Suggesting keywords, method names or even entire
code snippets, is a powerful tool an \gls{ide} can have. This is possible to
achieve, in some form, without being specialized, by for example, suggesting
text that already exist in the document, but is most useful if it is
specialized, and can suggest built-in methods. This allows a developer to not
having to remember exactly how methods are named, is the method to split a
string by some delimiter, \textit{split\_by} or \textit{split\_on}? As long as
the developer writes \textit{split}, the correct method name will be suggested.

\paragraph{Go-To-Definitions} Being able to quickly navigate to methods and read
their implementation is a useful tool for a developer, as less time has to be
spent navigating the project structure, to figure out where some method was
implemented, and more time can be spent actually developing.

A lot of these features are possible due to \textit{Language Server Protocols},
which allow for a standardized way for compilers to give code-support to
\gls{ide}'s.

\todo{Connect these better}

A generic \gls{ide} contains the features that are common among development in
any programming language, like:

\paragraph{File Explorer} Most project nowadays is larger than one file, so
being able to visualize the project in a tree-like-structure, and navigate that,
is useful. This feature usually comes with the ability to manipulate the project
structure, by adding files, folders, moving files around, and deleting them.

\todo{
  A lot of these claims are \textit{vibes} based, and should probably be more
  academic sounding
}

But creating any \gls{ide} would still limit the lifetime of the application. The best
example of a long living active \gls{ide}, or, at least editor, is Vim (source?). Vim
is not a feature full editor, but it is simple, lightweight, and works. But most
people use it, for how easy it is to extend; It's lifetime has been greatly
extended by the ease of modularization. Any popular module for Vim is
open-source, and therefore, if any module had an active community around it, if
the \textit{lead} developer of the module stopped developing it, that community
continue developing the module, either by getting maintenance access to the
repository, or by forking it. Ensuring the lifetime of the module.


The proposed modular IDE includes specific modules tailored for experimental
languages, such as ASR Transformation, Term Algebras, MoA translation, and STF.
As a part of this project, these plugins will be implemented to verify the
functionality of the modularization of the IDE.

We will discuss the different ways to achieve modularity within
an application. We will also point out different behaviors that arise from such
a setup.
