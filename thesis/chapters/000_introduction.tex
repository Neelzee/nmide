\chapter{Introduction}

Standard \gls{ide}s are indispensable tools in modern software development,
offering features like early bug reporting, project outline visualization, code
highlighting, and code completion, however, these \gls{ide}s may not adequately
support the unique demands of experimental programming languages. To solve this,
a modular approach is used to design, develop and implement an \gls{ide}.

We will discuss the different ways to achieve modularity within an application.
We will also point out different behaviors that arise from such a setup. The
target language will be Magnolia, an experimental research language being
developed by \gls{bldl} at the University of Bergen.


\section{Integrated Development Environment}

An \gls{ide}, aids a developer, as all the needed tools for development are
integrated into one application. There are two different kinds of \gls{ide}s,
generic and specialized. \todo{Source}

A specialized \gls{ide} is one targeted towards a specific language, like
Eclipse, (reference?), or IntelliJ (reference?), which target Java/JVM. It
contains specialized features like the following:

\paragraph{Syntax Highlighting} Highlighting important keywords, identifiers
and more, makes the language easier to read for the developer, allowing them to
spot easy to miss errors, like misspelling of keywords.

\paragraph{Code Autocompletion} Suggesting keywords, method names or even entire
code snippets, is a powerful tool an \gls{ide} can have. This is possible to
achieve, in some form, without being specialized, by for example, suggesting
text that already exist in the document, but is most useful if it is
specialized, and can suggest built-in methods. This allows a developer to not
having to remember exactly how methods are named, is the method to split a
string by some delimiter, \textit{split\_by} or \textit{split\_on}? As long as
the developer writes \textit{split}, the correct method name will be suggested.

\paragraph{Go-To-Definitions} Being able to quickly navigate to methods and read
their implementation is a useful tool for a developer, as less time has to be
spent navigating the project structure, to figure out where some method was
implemented, and more time can be spent actually developing.

A lot of these features are possible due to \textit{Language Server Protocols},
which allow for a standardized way for compilers to give code-support to
\gls{ide}'s.

A generic \gls{ide} contains the features that are common among development in
any programming language, like:

\paragraph{File Explorer} Most project nowadays is larger than one file, so
being able to visualize the project in a tree-like-structure, and navigate that,
is useful. This feature usually comes with the ability to manipulate the project
structure, by adding files, folders, moving files around, and deleting them.

But creating any \gls{ide} would still limit the lifetime of the application. The best
example of a long living active \gls{ide}, or, at least editor, is Vim (source?). Vim
is not a feature full editor, but it is simple, lightweight, and works on any
operating system. But most people use it, for how easy it is to extend; Its
lifetime has been greatly extended by the ease of modularization. Any popular
module for Vim is open-source, and therefore, if any module had an active
community around it, if the \textit{lead} developer of the module stopped
developing it, that community can continue to develop the module, either by
getting maintenance access to the repository, or by forking it. Ensuring the
lifetime of the module is extended.

\section{Experimental Languages}

Experimental languages introduce new concepts like \gls{asr} Transformation,
Term Algebras, \gls{moa}, and \gls{stf}. These are concepts from the
academic community, and are not common in \textit{mainstream} languages, and
as such, have little to no support in modern \gls{ide}s. For researches
developing these experimental languages, work arounds are needed, mostly in the
form of creating ad-hoc addons to the application, that gives it the capabilities
needed to partially or fully support the concept being introduced. This is done
by utilizing the existing module architecture the application exposes, which is
a common feature among modern \gls{ide}s. This means that experimental concepts
cannot be easily tested, because time has to be invested into an \gls{ide} to
investigate the changes needed, if that is even possible, to enable this
experimental concept to be used in the \gls{ide}.

A modular \gls{ide} would assist in this. Even if a new feature from an
experimental language is introduced, it is unlikely that this feature has no
relation to existing features, and as such, it is easier to extend the
application in such a manner to facilitate this new feature, with help of
existing modules.
If, however it is the case that this feature is paradigm-shifting, then there
will still be existing functionality that can be used, re-used or extended to
facilitate this.
