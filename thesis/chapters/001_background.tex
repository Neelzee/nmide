\chapter{Background}

Traditional IDEs encompass essential features such as syntax highlighting, code
navigation, and hover-help, playing a crucial role in the software development
process. However, their limitations become apparent when working with
experimental languages. This paper advocates for modularization and
\textit{composability} as key design principles, demonstrating their ability to
extend the operational lifespan of software by adapting to new paradigms and
tools. The discussion revolves around Magnolia, a generic programming language
developed at the University of Bergen, as a case study illustrating the need for
a specialized IDE. It is a way to experiment with generic programming. And to
achieve this in a sufficient manner, a more specialized IDE is required.

\section{Magnolia}

Magnolia is an experimental research language being developed \gls{bldl} at the
University of Bergen. Magnolia is designed to support a high level of abstraction
and ease of reasoning. This is achieved by \textit{concepts}, \textit{axioms} and
\textit{implementations}.

The example code shown in listing \ref{lst:binop}, showcases a concept
representation a binary operation, which has one function, \textit{binop}, which
takes in two values of type \textit{T}, and returns \textit{T}. Note that the
actual implementation of this function is missing. This is because a concept
encodes the properties of a users code. The actual implementation of the
\textit{binop} function needs to uphold the properties of the concept that is
being implemented. In this case, it is just that the input and output
of the function are of the same types.

\begin{center}
  \lstinputlisting
    [ language=Magnolia
    , caption={Binary Operation concept in Magnolia}
    , label=lst:binop]{./code/binop.mg}
\end{center}

In the example code shown in listing \ref{lst:semigroup}, the \textit{Binop}
concept has been expanded upon, still following the same rules as before, but
with the added property of associativity.

\begin{center}
  \lstinputlisting
    [ language=Magnolia
    , caption={Semigroup concept in Magnolia}
    , label=lst:semigroup]{./code/semigroup.mg}
\end{center}

\section{Existing Magnolia IDE}

The current \gls{ide} for Magnolia, is an (old?) version of Eclipse, using modules
and functionality from the core application, that has been outdated since
(around some date). This \gls{ide}s lifetime was limited by external modules and
features that where not maintained by \gls{bldl}. This meant that for future
development of Magnolia, an outdated \gls{ide} was needed, with outdated software
and (other reasons this was not good).

\todo{Add some mentions of open-source}
Modularization will help to mitigate some of the issues with the current
Magnolia \gls{ide}. Instead of maintaining an entire application, the needed and
wanted features of the application can be maintained instead.

Experimental languages might have features which are not possible to be fully
used in current \gls{ide}s. This is also the case for the current Magnolia
\gls{ide}. The compiler for Magnolia, syntax highlighting, error reporting, and
hover-functionality are functionality made in the Eclipse \gls{ide}, by using
its plug-in architecture. Some of the functionality and plug-ins this
implementation used, have been deprecated in later version of Eclipse. This
means the Magnolia \gls{ide} is locked to an old version of Eclipse, which, as
time passes, increases the complexity of installation, as the surrounding
tooling and libraries needed by this version of Eclipse also becomes deprecated.
Currently, in INF220, at the university, two weeks are set aside for students to
be able to install it.

\todo{Read/add reference to Anya's paper?}
\todo{Expand this}

\section{Software Longevity}

\todo{
  Should rewrite this to sound less like "I mean/feel this", to "I've
  observed this"
}
There are two interconnected reasons for a piece of software to last a long
time, it is either due to necessity, or due to popularity.

\todo{Find an example of software that sucks}
\todo{Explain what is meant by popular, maybe a chance to add graphs? O.o}
\todo{Find a source for this claim.}
Most examples of \textit{popular} software, are open source, like \gls{vim}.
\gls{vim} is a text editor which has been in use since 1991. There are several
factors behind this success, but the ones being highlighted here, are due to its
extensibility and due to it being open-sourced. Being open sourced, allows for a
rotating cast of maintainers, ensuring the core application has the features its
users wants. The users of \gls{vim} can be split into two categories,
\textit{standard users}, and \textit{plugin developers}. \gls{vim} has an
extensive plugin ecosystem, which can extend \gls{vim}s functionality from a
text editor, to a fully fledged \gls{ide}.

\section{Language Server}

\todo{
  Could probably add some sentences about the history of LSP, to get more words
  in.
}

The most important features in an \gls{ide} are possible due to the \gls{lsp}.
\gls{lsp} is a protocol for a language server and editor, (the client),
with which they communicate, allowing for features like code completion, syntax
highlighting, marking of warnings and errors, as well as refactoring routines.
This is the limiting factor when it comes to supporting experimental languages,
as not only does a new set of protocols need to be appended to a language server,
the editor itself needs to be changed to actually use these protocols. This
creates a lot of work, for both the \gls{ide} developer and for the compiler
developer. Here is where a modular approach can help both. If some new
functionality or feature is added to the experimental language, this off course
means the compiler/interpreter has to be expanded/modified, but for the
\gls{ide}, a module could be added/modified to utilize this change, instead of
having to change the entire application.
