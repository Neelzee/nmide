\chapter{Background}

Traditional IDEs encompass essential features such as syntax highlighting, code
navigation, and hover-help, playing a crucial role in the software development
process. However, their limitations become apparent when working with
experimental languages. The paper advocates for modularization and \textit{composability}
as key design principles, demonstrating their ability to extend the operational
lifespan of software by adapting to new paradigms and tools. The discussion
revolves around Magnolia, a generic programming language developed at UIB, as a
case study illustrating the need for a specialized IDE. It is a way to experiment
with generic programming. And to achieve this in a sufficient manner, a more
specialized IDE is required.

\section{Magnolia}

\begin{itemize}
  \item A research programming language being developed by
    Bergen Language Design Laboratory at the University of Bergen
  \item Introduces something called \textit{concepts}
  \item Similar to a Java interface.
  \item A concept declares
    \begin{itemize}
      \item Types
      \item Operations on those Types
      \item Axioms that specify the behavior of the Operations
    \end{itemize}
  \item A concept can use other concepts, and rename the Types and Operations
    in the concept, this is called renaming
\end{itemize}

\begin{figure}
  \centering
  \input{./code/binop}
  \caption{Binary Operation concept in Magnolia}
\end{figure}

\begin{figure}
  \centering
  \input{./code/semigroup}
  \caption{Semigroup concept in Magnolia}
\end{figure}


\subsection{Abstract Semantic Representation Transformation}

The ASR of a language, is an extension of a normal Abstract Syntax Tree (AST),
but with extra information. This representation of the syntax is handy when
developing. Specifically for Magnolia, the interest is in the transformation of
this ASR; the flattened version.

% The point of this sub-section, is to explain what happened previously at UIB, and
% why this is the best way to do it
\section{Background at UIB}

% TODO: Some paragraphs about what happened before
The current IDE for Magnolia, is an (old?) version of Eclipse, using some
modules/features that was outdated (around some date). This IDE's lifetime was
limited by external modules/features that where not maintained by UIB. This
meant that for future development of Magnolia, an outdated IDE was needed, with
outdated software and (other reasons this was not good). A solution could be to
use something like "Visual Studio Code", which is a very popular IDE (source?),
more popular than Eclipse (source?).

% TODO: Why not VS-Code?
% TODO: Add some mentions of open-source
Then new development of the new IDE, then, would be turned around, instead of
maintaining an IDE, the modules for the IDE would be maintained. While it is
unlikely that "Visual Studio Code" will be deprecated in the near future, it
could still happen. The best solution is to keep everything internal.

% TODO: Rewrite to be more academic enough
But creating any IDE would still limit the lifetime of the application. The best
example of a long living active IDE, or, atleast editor, is Vim (source?). Vim
is not a feature full editor, but it is simple, lightweight, and works. But most
people use it, for how easy it is to extend; It's lifetime has been greatly
extended by the ease of modularization. Any popular module for Vim is
open-source, and therefore, if any module had an active community around it, if
the \textit{lead} developer of the module stopped developing it, that community
continue developing the module, either by getting maintenance access to the
repository, or by forking it. Ensuring the lifetime of the module.

\section{Current Magnolia IDE}
