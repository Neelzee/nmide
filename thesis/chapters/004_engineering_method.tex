\chapter{Engineering method}

\section{Modularity}

\subsection{Granularity}

\subsection{Module families}

\section{Tech Stack}

\section{Architecture}

% TODO: Some explanation on why this is an issue
% Also talk about what we tried first

First attempt was to create a Visual Studio Code Copy. This would've worked, but
would've created a lot of extra work.


\subsection{Elm-Architecture}

% TODO: Insert the elm-lang architecture graph
% TODO: Also explain elm-lang

\subsection{Module Architecture}

In this application, the Elm-box is a module, while the runtime system, is the
core itself. The core invokes all modules, all of which, should have these three
functions defined:

% TODO: Add haskell code example of this

\input{./code/plugin-types}

\begin{itemize}
  \item init :: Model -> Model
  \item view :: Model -> [(Html, Location)]
  \item update :: Msg -> Model -> Model
\end{itemize}

Firstly, the types.

% TODO: Rename `Model` to `State` or something similar
\paragraph{Model}
Model is the \textit{state} of the application. In this case, it has the same
structure as a JSON object. A few values are set at the start of the
application, so it looks like this:

% TODO: Insert some code-snippet that showcases the model
% \text{\{ "location": \{ "main": \[ \] \} \}}

% TODO: Should probably explain before-hand that the core uses webview to
% display stuff.
So, the way any module inserts HTML into the IDE, is by sending a tuple, of the
HTML, and Location, which is where the HTML element should be inserted. Main
corresponds to the <main>-tag in a standard HTML document, like so:

html > body > main

But this introduces a possibility for some hierarchy in the module ecosystem.
For example, a module could act as a framework, and therefore needs to only be
loaded once, creating new locations, with styling.


\paragraph{HTML}
Just a representation of HTML
% TODO: Expand


\paragraph{Location}
Just a type-alias for String, to ensure type-safety
% TODO: Expand


\paragraph{Msg}
Modules create Msg-s, that are sent to all other plugins that subscribe to them.

For example, if a module creates some Button, that when pressed sends
Msg "\textit{btn\-clicked}", then any module that are listening for this message, can pick
it up, when a user clicks on the button, and then optionally change the Model.
